//! Skill package generation - creates SKILL.md, auth.json, api.ts

use crate::types::*;
use napi::bindgen_prelude::*;
use napi_derive::napi;
use sha2::{Sha256, Digest};
use std::collections::{HashMap, HashSet};
use std::fs;
use std::path::PathBuf;

/// Generate a version hash from endpoints
fn generate_version_hash(endpoints: &[EndpointInfo]) -> String {
    let mut hasher = Sha256::new();
    for ep in endpoints {
        hasher.update(format!("{}:{}", ep.method, ep.path));
    }
    let result = hasher.finalize();
    format!("{:x}", result)[..8].to_string()
}

/// Convert service name to PascalCase class name
fn to_class_name(service: &str) -> String {
    service
        .split(|c: char| c == '-' || c == '_' || c == '.')
        .filter(|s| !s.is_empty())
        .map(|s| {
            let mut chars: Vec<char> = s.chars().collect();
            if let Some(c) = chars.first_mut() {
                *c = c.to_ascii_uppercase();
            }
            chars.into_iter().collect::<String>()
        })
        .collect()
}

/// Generate SKILL.md content
fn generate_skill_md(
    service: &str,
    base_url: &str,
    auth_method: &str,
    endpoints: &[EndpointInfo],
    description: Option<&str>,
    author: Option<&str>,
    tags: Option<&[String]>,
    price_usdc: Option<f64>,
) -> String {
    let mut md = String::new();

    // Header
    md.push_str(&format!("# {}\n\n", to_class_name(service)));

    // Description
    if let Some(desc) = description {
        md.push_str(&format!("{}\n\n", desc));
    } else {
        md.push_str(&format!("Internal API skill for {}.\n\n", service));
    }

    // Metadata
    md.push_str("## Metadata\n\n");
    md.push_str(&format!("- **Service**: {}\n", service));
    md.push_str(&format!("- **Base URL**: {}\n", base_url));
    md.push_str(&format!("- **Auth Method**: {}\n", auth_method));
    if let Some(auth) = author {
        md.push_str(&format!("- **Author**: {}\n", auth));
    }
    if let Some(t) = tags {
        md.push_str(&format!("- **Tags**: {}\n", t.join(", ")));
    }
    if let Some(price) = price_usdc {
        md.push_str(&format!("- **Price**: ${:.2} USDC\n", price));
    }
    md.push_str(&format!("- **Endpoints**: {}\n", endpoints.len()));
    md.push_str(&format!("- **Version**: {}\n", generate_version_hash(endpoints)));
    md.push_str("\n");

    // Endpoints
    md.push_str("## Endpoints\n\n");
    for ep in endpoints {
        md.push_str(&format!("### `{} {}`\n\n", ep.method, ep.path));
        if let Some(desc) = &ep.description {
            md.push_str(&format!("{}\n\n", desc));
        }
        if let Some(resp_type) = &ep.response_type {
            md.push_str(&format!("**Response**: `{}`\n\n", resp_type));
        }
    }

    // Usage
    md.push_str("## Usage\n\n");
    md.push_str("```typescript\n");
    md.push_str(&format!("import {{ {}Client }} from './scripts/api';\n\n", to_class_name(service)));
    md.push_str(&format!("const client = await {}Client.fromAuthFile('./auth.json');\n", to_class_name(service)));
    md.push_str("// Use client methods...\n");
    md.push_str("```\n");

    md
}

/// Generate api.ts content
fn generate_api_ts(
    service: &str,
    base_url: &str,
    auth_method: &str,
    endpoints: &[EndpointInfo],
) -> String {
    let class_name = to_class_name(service);
    let primary_auth_header = if auth_method.to_lowercase().contains("bearer") {
        "Authorization"
    } else {
        "authorization"
    };

    let mut ts = String::new();

    // Header
    ts.push_str(&format!("/**\n * {} API Client\n", class_name));
    ts.push_str(&format!(" * Generated by Unbrowse for skill: {}\n", service));
    ts.push_str(" */\n\n");

    // Imports
    ts.push_str("import { readFileSync, existsSync } from \"node:fs\";\n\n");

    // Types
    ts.push_str("interface RequestOptions {\n");
    ts.push_str("  params?: Record<string, string>;\n");
    ts.push_str("  body?: unknown;\n");
    ts.push_str("  headers?: Record<string, string>;\n");
    ts.push_str("}\n\n");

    // Class
    ts.push_str(&format!("export class {}Client {{\n", class_name));
    ts.push_str("  readonly baseUrl: string;\n");
    ts.push_str("  private authToken?: string;\n");
    ts.push_str("  private cookies: Record<string, string>;\n");
    ts.push_str("  private extraHeaders: Record<string, string>;\n");
    ts.push_str("  private timeout: number;\n\n");

    // Constructor
    ts.push_str("  constructor(opts: {\n");
    ts.push_str("    baseUrl?: string;\n");
    ts.push_str("    authToken?: string;\n");
    ts.push_str("    cookies?: Record<string, string>;\n");
    ts.push_str("    extraHeaders?: Record<string, string>;\n");
    ts.push_str("    timeout?: number;\n");
    ts.push_str("  } = {}) {\n");
    ts.push_str(&format!("    this.baseUrl = opts.baseUrl ?? \"{}\";\n", base_url));
    ts.push_str("    this.authToken = opts.authToken;\n");
    ts.push_str("    this.cookies = opts.cookies ?? {};\n");
    ts.push_str("    this.extraHeaders = opts.extraHeaders ?? {};\n");
    ts.push_str("    this.timeout = opts.timeout ?? 30_000;\n");
    ts.push_str("  }\n\n");

    // fromAuthFile static method
    ts.push_str(&format!("  static async fromAuthFile(authPath: string): Promise<{}Client> {{\n", class_name));
    ts.push_str("    if (!existsSync(authPath)) {\n");
    ts.push_str("      throw new Error(`Auth file not found: ${authPath}`);\n");
    ts.push_str("    }\n");
    ts.push_str("    const auth = JSON.parse(readFileSync(authPath, \"utf-8\"));\n");
    ts.push_str(&format!("    return new {}Client({{\n", class_name));
    ts.push_str("      baseUrl: auth.baseUrl,\n");
    ts.push_str(&format!("      authToken: auth.headers?.[\"{}\"] ?? auth.headers?.authorization,\n", primary_auth_header));
    ts.push_str("      cookies: auth.cookies ?? {},\n");
    ts.push_str("      extraHeaders: auth.headers ?? {},\n");
    ts.push_str("    });\n");
    ts.push_str("  }\n\n");

    // Private request method
    ts.push_str("  private async request<T>(method: string, path: string, opts: RequestOptions = {}): Promise<T> {\n");
    ts.push_str("    let url = `${this.baseUrl}${path}`;\n");
    ts.push_str("    if (opts.params) {\n");
    ts.push_str("      const qs = new URLSearchParams(opts.params).toString();\n");
    ts.push_str("      url += `?${qs}`;\n");
    ts.push_str("    }\n\n");
    ts.push_str("    const headers: Record<string, string> = {\n");
    ts.push_str("      \"Content-Type\": \"application/json\",\n");
    ts.push_str("      ...this.extraHeaders,\n");
    ts.push_str("      ...opts.headers,\n");
    ts.push_str("    };\n\n");
    ts.push_str("    if (this.authToken) {\n");
    ts.push_str(&format!("      headers[\"{}\"] = this.authToken;\n", primary_auth_header));
    ts.push_str("    }\n\n");
    ts.push_str("    if (Object.keys(this.cookies).length > 0) {\n");
    ts.push_str("      headers[\"Cookie\"] = Object.entries(this.cookies)\n");
    ts.push_str("        .map(([k, v]) => `${k}=${v}`)\n");
    ts.push_str("        .join(\"; \");\n");
    ts.push_str("    }\n\n");
    ts.push_str("    const response = await fetch(url, {\n");
    ts.push_str("      method,\n");
    ts.push_str("      headers,\n");
    ts.push_str("      body: opts.body ? JSON.stringify(opts.body) : undefined,\n");
    ts.push_str("      signal: AbortSignal.timeout(this.timeout),\n");
    ts.push_str("    });\n\n");
    ts.push_str("    if (!response.ok) {\n");
    ts.push_str("      throw new Error(`API error: ${response.status} ${response.statusText}`);\n");
    ts.push_str("    }\n\n");
    ts.push_str("    const contentType = response.headers.get(\"content-type\");\n");
    ts.push_str("    if (contentType?.includes(\"application/json\")) {\n");
    ts.push_str("      return response.json();\n");
    ts.push_str("    }\n");
    ts.push_str("    return response.text() as unknown as T;\n");
    ts.push_str("  }\n\n");

    // Generate methods for each endpoint
    let mut seen_methods: HashSet<String> = HashSet::new();
    for ep in endpoints {
        let method_name = generate_method_name(&ep.method, &ep.path, &mut seen_methods);

        // Method signature
        if ep.method == "GET" {
            ts.push_str(&format!("  async {}(params?: Record<string, string>): Promise<unknown> {{\n", method_name));
            ts.push_str(&format!("    return this.request(\"{}\", \"{}\", {{ params }});\n", ep.method, ep.path));
        } else {
            ts.push_str(&format!("  async {}(body?: unknown, params?: Record<string, string>): Promise<unknown> {{\n", method_name));
            ts.push_str(&format!("    return this.request(\"{}\", \"{}\", {{ body, params }});\n", ep.method, ep.path));
        }
        ts.push_str("  }\n\n");
    }

    ts.push_str("}\n");
    ts
}

/// Generate a method name from HTTP method and path
fn generate_method_name(method: &str, path: &str, seen: &mut HashSet<String>) -> String {
    let prefix = match method {
        "GET" => "get",
        "POST" => "create",
        "PUT" => "update",
        "PATCH" => "patch",
        "DELETE" => "delete",
        _ => "call",
    };

    // Extract meaningful parts from path
    let parts: Vec<&str> = path
        .split('/')
        .filter(|s| !s.is_empty() && !s.starts_with(':') && !s.starts_with('{'))
        .collect();

    let suffix = if parts.is_empty() {
        "Root".to_string()
    } else {
        parts
            .iter()
            .map(|s| {
                let mut chars: Vec<char> = s.chars().collect();
                if let Some(c) = chars.first_mut() {
                    *c = c.to_ascii_uppercase();
                }
                chars.into_iter().collect::<String>()
            })
            .collect::<String>()
    };

    let mut name = format!("{}{}", prefix, suffix);

    // Handle duplicates
    let mut counter = 1;
    let original_name = name.clone();
    while seen.contains(&name) {
        counter += 1;
        name = format!("{}{}", original_name, counter);
    }
    seen.insert(name.clone());

    name
}

/// Generate auth.json content
fn generate_auth_json_content(
    service: &str,
    base_url: &str,
    auth_method: &str,
    auth_headers: &HashMap<String, String>,
    cookies: &HashMap<String, String>,
) -> String {
    let auth = serde_json::json!({
        "service": service,
        "baseUrl": base_url,
        "authMethod": auth_method,
        "headers": auth_headers,
        "cookies": cookies,
    });

    serde_json::to_string_pretty(&auth).unwrap_or_default()
}

/// Generate a complete skill package
#[napi]
pub fn generate_skill(
    data: ApiData,
    output_dir: Option<String>,
    meta: Option<SkillMeta>,
) -> Result<SkillResult> {
    let service = &data.service;
    let base_url = &data.base_url;
    let auth_method = &data.auth_method;

    // Determine output directory
    let skill_dir = if let Some(dir) = output_dir {
        PathBuf::from(dir)
    } else {
        let home = dirs::home_dir().unwrap_or_else(|| PathBuf::from("."));
        home.join(".openclaw").join("skills").join(service)
    };

    // Create directories
    fs::create_dir_all(skill_dir.join("scripts"))
        .map_err(|e| Error::from_reason(format!("Failed to create skill dir: {}", e)))?;
    fs::create_dir_all(skill_dir.join("references"))
        .map_err(|e| Error::from_reason(format!("Failed to create references dir: {}", e)))?;

    // Extract unique endpoints
    let mut endpoints: Vec<EndpointInfo> = Vec::new();
    let mut seen_paths: HashSet<String> = HashSet::new();

    for req in &data.requests {
        let key = format!("{}:{}", req.method, req.path);
        if !seen_paths.contains(&key) {
            seen_paths.insert(key);

            // Try to infer response type
            let response_type = req.response_content_type.as_ref().and_then(|ct| {
                if ct.contains("json") {
                    Some("json".to_string())
                } else if ct.contains("text") {
                    Some("text".to_string())
                } else {
                    None
                }
            });

            endpoints.push(EndpointInfo {
                method: req.method.clone(),
                path: req.path.clone(),
                description: None,
                response_type,
            });
        }
    }

    // Get metadata
    let (description, author, tags, price_usdc) = if let Some(m) = meta {
        (m.description, m.author, m.tags, m.price_usdc)
    } else {
        (None, None, None, None)
    };

    // Generate SKILL.md
    let skill_md = generate_skill_md(
        service,
        base_url,
        auth_method,
        &endpoints,
        description.as_deref(),
        author.as_deref(),
        tags.as_deref(),
        price_usdc,
    );
    let skill_md_path = skill_dir.join("SKILL.md");
    fs::write(&skill_md_path, &skill_md)
        .map_err(|e| Error::from_reason(format!("Failed to write SKILL.md: {}", e)))?;

    // Generate auth.json
    let auth_json = generate_auth_json_content(
        service,
        base_url,
        auth_method,
        &data.auth_headers,
        &data.cookies,
    );
    let auth_json_path = skill_dir.join("auth.json");
    fs::write(&auth_json_path, &auth_json)
        .map_err(|e| Error::from_reason(format!("Failed to write auth.json: {}", e)))?;

    // Generate api.ts
    let api_ts = generate_api_ts(service, base_url, auth_method, &endpoints);
    let api_ts_path = skill_dir.join("scripts").join("api.ts");
    fs::write(&api_ts_path, &api_ts)
        .map_err(|e| Error::from_reason(format!("Failed to write api.ts: {}", e)))?;

    Ok(SkillResult {
        service: service.clone(),
        skill_dir: skill_dir.to_string_lossy().to_string(),
        skill_md_path: skill_md_path.to_string_lossy().to_string(),
        auth_json_path: auth_json_path.to_string_lossy().to_string(),
        api_ts_path: api_ts_path.to_string_lossy().to_string(),
        endpoints_count: endpoints.len() as i32,
        auth_method: auth_method.clone(),
    })
}

/// List all learned skills
#[napi]
pub fn list_skills() -> Result<Vec<String>> {
    let home = dirs::home_dir().unwrap_or_else(|| PathBuf::from("."));
    let skills_dir = home.join(".openclaw").join("skills");

    if !skills_dir.exists() {
        return Ok(vec![]);
    }

    let entries = fs::read_dir(&skills_dir)
        .map_err(|e| Error::from_reason(format!("Failed to read skills dir: {}", e)))?;

    let mut skills: Vec<String> = Vec::new();
    for entry in entries.flatten() {
        if entry.file_type().map(|t| t.is_dir()).unwrap_or(false) {
            let skill_md = entry.path().join("SKILL.md");
            if skill_md.exists() {
                if let Some(name) = entry.file_name().to_str() {
                    skills.push(name.to_string());
                }
            }
        }
    }

    skills.sort();
    Ok(skills)
}

/// Get skill info by name
#[napi]
pub fn get_skill_info(service: String) -> Result<Option<SkillSummary>> {
    let home = dirs::home_dir().unwrap_or_else(|| PathBuf::from("."));
    let skill_dir = home.join(".openclaw").join("skills").join(&service);

    if !skill_dir.exists() {
        return Ok(None);
    }

    let skill_md_path = skill_dir.join("SKILL.md");
    let auth_json_path = skill_dir.join("auth.json");

    if !skill_md_path.exists() {
        return Ok(None);
    }

    // Read SKILL.md to extract info
    let skill_md = fs::read_to_string(&skill_md_path)
        .map_err(|e| Error::from_reason(format!("Failed to read SKILL.md: {}", e)))?;

    // Parse metadata from SKILL.md
    let mut base_url = String::new();
    let mut auth_method = String::new();
    let mut endpoints_count = 0;
    let mut version = String::new();

    for line in skill_md.lines() {
        if line.starts_with("- **Base URL**:") {
            base_url = line.split(':').skip(1).collect::<Vec<_>>().join(":").trim().to_string();
        } else if line.starts_with("- **Auth Method**:") {
            auth_method = line.split(':').skip(1).collect::<Vec<_>>().join(":").trim().to_string();
        } else if line.starts_with("- **Endpoints**:") {
            if let Some(count) = line.split(':').nth(1) {
                endpoints_count = count.trim().parse().unwrap_or(0);
            }
        } else if line.starts_with("- **Version**:") {
            version = line.split(':').nth(1).unwrap_or("").trim().to_string();
        }
    }

    // Get file modification time
    let metadata = fs::metadata(&skill_md_path).ok();
    let updated_at = metadata
        .and_then(|m| m.modified().ok())
        .map(|t| chrono::DateTime::<chrono::Utc>::from(t).to_rfc3339())
        .unwrap_or_else(|| chrono::Utc::now().to_rfc3339());

    Ok(Some(SkillSummary {
        id: service.clone(),
        name: to_class_name(&service),
        service,
        description: None,
        author: "local".to_string(),
        author_wallet: None,
        version,
        endpoints_count,
        installs: 0,
        executions: 0,
        price_usdc: None,
        tags: None,
        badge: None,
        created_at: updated_at.clone(),
        updated_at,
    }))
}
