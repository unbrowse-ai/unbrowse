#!/usr/bin/env bun
/**
 * Replay-v2 suite runner (staging-friendly).
 *
 * Reads a JSON suite, loads each skill's latest capture session, finds the best
 * captured target exchange for the endpoint, then executes the prerequisite chain
 * using v2 correlations.
 *
 * Run:
 *   cd packages/plugin && bun test/evals/run-replay-v2-suite.ts --suite ./test/evals/replay-v2-suite.example.json
 *
 * Notes:
 * - Requires <skillDir>/captures/session-*.json (generated by unbrowse_capture/learn/browse).
 * - Uses Node fetch by default; can optionally attempt stealth transport via node-libcurl-ja3.
 */

import { existsSync, readdirSync, readFileSync } from "node:fs";
import { join, resolve } from "node:path";
import { homedir } from "node:os";

import type { CaptureSessionFileV1 } from "../../src/types.js";
import { inferCorrelationGraphV1 } from "../../src/correlation-engine.js";
import { executeCaptureChainForTarget, findBestCapturedTargetIndex } from "../../src/replay-v2.js";
import { fetchViaNodeStealth } from "../../src/transport.js";

type SuiteV1 = {
  version: 1;
  skillsDir?: string;
  cases: Array<{
    name: string;
    service: string;
    endpoint: string; // "GET /path"
    executionMode?: "node";
    useStealth?: boolean;
    autoChain?: boolean;
    expect?: {
      statusIn?: [number, number];
      bodyIncludes?: string[];
      jsonPathExists?: string[];
    };
  }>;
};

function expandHome(p: string): string {
  if (p.startsWith("~/")) return join(homedir(), p.slice(2));
  return p;
}

function parseEndpoint(s: string): { method: string; pathOrUrl: string } {
  const m = String(s || "").trim().match(/^(GET|POST|PUT|PATCH|DELETE)\s+(.+)$/i);
  if (m) return { method: m[1].toUpperCase(), pathOrUrl: m[2] };
  return { method: "GET", pathOrUrl: String(s || "").trim() };
}

function loadLatestCapture(skillDir: string): CaptureSessionFileV1 {
  const capturesDir = join(skillDir, "captures");
  if (!existsSync(capturesDir)) throw new Error(`captures/ missing: ${capturesDir}`);
  const files = readdirSync(capturesDir)
    .filter((f) => f.startsWith("session-") && f.endsWith(".json"))
    .sort();
  const latest = files[files.length - 1];
  if (!latest) throw new Error(`no session-*.json in ${capturesDir}`);
  const raw = readFileSync(join(capturesDir, latest), "utf-8");
  const parsed = JSON.parse(raw) as CaptureSessionFileV1;
  if (!parsed || parsed.version !== 1 || !Array.isArray(parsed.exchanges)) {
    throw new Error(`invalid capture session: ${join(capturesDir, latest)}`);
  }
  return parsed;
}

function getAtPath(obj: any, path: string): unknown {
  const tokens = String(path || "").split(".").filter(Boolean);
  let cur = obj;
  for (const t of tokens) {
    if (cur == null) return undefined;
    cur = cur[t];
  }
  return cur;
}

async function main() {
  const args = process.argv.slice(2);
  const suitePath = (() => {
    const idx = args.indexOf("--suite");
    if (idx >= 0) return args[idx + 1];
    return process.env.UNBROWSE_REPLAY_V2_SUITE;
  })();
  if (!suitePath) {
    console.error("missing --suite <path> (or UNBROWSE_REPLAY_V2_SUITE)");
    process.exit(2);
  }

  const suiteAbs = resolve(expandHome(suitePath));
  const suite = JSON.parse(readFileSync(suiteAbs, "utf-8")) as SuiteV1;
  if (!suite || suite.version !== 1 || !Array.isArray(suite.cases)) {
    throw new Error(`invalid suite: ${suiteAbs}`);
  }

  const skillsDir = expandHome(suite.skillsDir ?? process.env.UNBROWSE_SKILLS_DIR ?? join(homedir(), ".openclaw", "skills"));

  let pass = 0;
  let fail = 0;
  const lines: string[] = [];
  lines.push(`=== replay-v2 suite ===`);
  lines.push(`suite: ${suiteAbs}`);
  lines.push(`skillsDir: ${skillsDir}`);
  lines.push("");

  for (const c of suite.cases) {
    const ep = parseEndpoint(c.endpoint);
    const skillDir = join(skillsDir, c.service);

    try {
      const capture = loadLatestCapture(skillDir);
      const exchanges = capture.exchanges;
      const graph = inferCorrelationGraphV1(exchanges);

      const targetIdx = findBestCapturedTargetIndex(exchanges, { method: ep.method, pathOrUrl: ep.pathOrUrl });
      if (targetIdx == null) throw new Error(`no captured match for ${ep.method} ${ep.pathOrUrl}`);

      const useStealth = typeof c.useStealth === "boolean" ? c.useStealth : true;

      const result = await executeCaptureChainForTarget(
        exchanges,
        graph,
        targetIdx,
        async (r) => {
          // Node transport: stealth (optional) -> native fetch
          if (useStealth) {
            const stealth = await fetchViaNodeStealth(r.url, {
              method: r.method,
              headers: r.headers,
              bodyText: r.bodyText,
              timeoutMs: 15_000,
              profile: "Chrome",
            });
            if (stealth) {
              const ct = stealth.headers["content-type"] ?? stealth.headers["Content-Type"];
              return { status: stealth.status, headers: stealth.headers, bodyText: stealth.bodyText, contentType: ct };
            }
          }

          const resp = await fetch(r.url, {
            method: r.method,
            headers: r.headers,
            body: r.bodyText,
            redirect: "manual",
            signal: AbortSignal.timeout(15_000),
          });
          const text = await resp.text().catch(() => "");
          const headers: Record<string, string> = {};
          resp.headers.forEach((v, k) => { headers[k] = v; });
          return { status: resp.status, headers, bodyText: text, contentType: headers["content-type"] };
        },
      );

      const status = result.final?.status ?? 0;
      const bodyText = result.final?.bodyText ?? "";
      const bodyJson = result.final?.bodyJson;

      const expect = c.expect ?? {};
      const statusOk = (() => {
        if (!expect.statusIn) return status >= 200 && status < 300;
        return status >= expect.statusIn[0] && status <= expect.statusIn[1];
      })();
      const includesOk = (expect.bodyIncludes ?? []).every((s) => bodyText.includes(s));
      const jsonPathOk = (expect.jsonPathExists ?? []).every((p) => getAtPath(bodyJson as any, p) !== undefined);

      const ok = statusOk && includesOk && jsonPathOk;

      if (ok) {
        pass++;
        lines.push(`PASS  ${c.name}  (${c.service})  ${c.endpoint}  status=${status}  chainLen=${result.chain.length}`);
      } else {
        fail++;
        const reasons: string[] = [];
        if (!statusOk) reasons.push("status");
        if (!includesOk) reasons.push("bodyIncludes");
        if (!jsonPathOk) reasons.push("jsonPathExists");
        lines.push(`FAIL  ${c.name}  (${c.service})  ${c.endpoint}  status=${status}  chainLen=${result.chain.length}  reasons=${reasons.join(",")}`);
      }
    } catch (err) {
      fail++;
      lines.push(`FAIL  ${c.name}  (${c.service})  ${c.endpoint}  error=${(err as Error).message}`);
    }
  }

  lines.push("");
  lines.push(`summary: pass=${pass} fail=${fail}`);
  console.log(lines.join("\n"));

  process.exit(fail > 0 ? 1 : 0);
}

main().catch((e) => {
  console.error(String((e as Error)?.stack || (e as Error)?.message || e));
  process.exit(1);
});

